==============================
PROJECT COMMAND DUMP
==============================

$ ls -a
.
..
.env
.git
README.md
ai_scanner
backend
docker-compose.yml
frontend
listing_backend.sh
listing_frontend.sh
mailserver
project_dump_backend.txt
project_dump_frontend.txt

$ cat .env docker-compose.yml
DJANGO_SUPERUSER_USERNAME=admin
DJANGO_SUPERUSER_PASSWORD=admin123
DJANGO_SUPERUSER_EMAIL=admin@example.com

POSTGRES_DB=backend_db
POSTGRES_USER=django
POSTGRES_PASSWORD=django123
POSTGRES_HOST=db
POSTGRES_PORT=5432

DJANGO_SECRET_KEY=supersecret123

REAL_MAILSERVER_URL=http://mailserver:8080/send
REAL_AISCANNER_URL=http://aiscanner:5000/scan
USE_REAL_SERVICES=auto

SCANNER_API_KEY=super-secret-key

version: '3.9'

services:
  backend:
    build: ./backend
    container_name: backend
    volumes:
      - ./backend:/app
    ports:
      - "8000:8000"
    env_file:
      - .env
    depends_on:
      - db

  db:
    image: postgres:16
    container_name: db
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  
  redis:
    image: redis:7
    ports:
      - "6379:6379"

  ml_scanner:
    build: ./ai_scanner
    container_name: ml_scanner
    ports:
      - "8001:8000"

volumes:
  postgres_data:

$ cd backend
$ ls
Dockerfile
README.md
backend
docs
emails
entrypoint.sh
manage.py
middleware
project_dump.txt
pytest.ini
realtime
requirements.txt
scanner
tests
users

$ cat Dockerfile
FROM python:3.12-slim

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

WORKDIR /app

# Install netcat
RUN apt-get update && apt-get install -y netcat-openbsd && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

CMD ["/entrypoint.sh"]

$ cat requirements.txt
Django>=5.0
djangorestframework
djangorestframework-simplejwt
drf-yasg
psycopg2-binary
requests
pytest
pytest-django
pytest-cov
requests-mock
graphene-django
django-filter
channels 
channels-redis 
django-cors-headers
django-graphql-jwt
python-json-logger
$ cat entrypoint.sh
#!/bin/sh

set -e

echo "â³ Waiting for PostgreSQL to be ready..."

while ! nc -z db 5432; do
  sleep 1
done

echo "âœ… PostgreSQL is available!"

echo "ğŸ“¦ Applying migrations..."
python manage.py migrate --noinput

echo "ğŸ‘‘ Creating superuser if not exists..."

python manage.py shell <<EOF
import os
from django.contrib.auth import get_user_model

User = get_user_model()

username = os.getenv("DJANGO_SUPERUSER_USERNAME")
email = os.getenv("DJANGO_SUPERUSER_EMAIL")
password = os.getenv("DJANGO_SUPERUSER_PASSWORD")

if username and password and email:
    if not User.objects.filter(username=username).exists():
        User.objects.create_superuser(
            username=username,
            email=email,
            password=password
        )
        print("âœ… Superuser created")
    else:
        print("â„¹ï¸ Superuser already exists")
else:
    print("âš ï¸ Superuser env vars not set, skipping")
EOF


echo "ğŸš€ Starting Django server..."
exec python manage.py runserver 0.0.0.0:8000

$ cat manage.py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

$ ls emails
__init__.py
admin.py
apps.py
interfaces.py
management
migrations
mock_service.py
models.py
schema.py
services.py
signals.py
tests.py
urls.py
views.py

$ cat emails/*.py
from django.contrib import admin
from .models import Email

@admin.register(Email)
class EmailAdmin(admin.ModelAdmin):
    list_display = ("id", "sender", "subject", "created_at")
    search_fields = ("sender", "subject", "body")
    list_filter = ("created_at",)
from django.apps import AppConfig


class EmailsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "emails"

    def ready(self):
        import emails.signals  # noqa
class EmailServiceInterface:
    def send_email(self, to, subject, body):
        raise NotImplementedError
    
    def scan_email(self, content):
        raise NotImplementedError
import random
from .interfaces import EmailServiceInterface

class MockEmailService(EmailServiceInterface):
    def send_email(self, to, subject, body):
        return {
            "id": random.randint(1000,9999),
            "to": to,
            "subject": subject,
            "status": "sent_mock"
        }

    def scan_email(self, content):
        return {
            "scan_id": random.randint(1,9999),
            "malicious": random.choice([True, False]),
            "confidence": round(random.random(),2)
        }

mock_service = MockEmailService()
from django.conf import settings
from django.db import models

class Email(models.Model):
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name="emails"
    )

    sender = models.EmailField()
    recipient = models.EmailField(null=True, blank=True)

    subject = models.CharField(max_length=255)
    body = models.TextField()

    # Inbox logic
    folder = models.CharField(
        max_length=20,
        choices=[("inbox", "Inbox"), ("sent", "Sent")],
        default="inbox"
    )

    is_outgoing = models.BooleanField(default=False)

    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Email from {self.sender} to {self.recipient} - {self.subject}"import graphene
from graphene_django import DjangoObjectType

from backend.common.graphql_permissions import login_required
from emails.models import Email
from scanner.models import ScanLog
from emails.mock_service import mock_service
from scanner.service_selector import try_real_send_email


# =====================
# TYPES
# =====================

class ScanLogType(DjangoObjectType):
    class Meta:
        model = ScanLog
        fields = ("result", "confidence", "created_at")


class EmailType(DjangoObjectType):
    scan = graphene.Field(ScanLogType)

    class Meta:
        model = Email
        fields = (
            "id",
            "sender",
            "recipient",
            "subject",
            "body",
            "folder",
            "created_at",
        )

    def resolve_scan(self, info):
        return (
            ScanLog.objects
            .filter(email=self)
            .order_by("-created_at")
            .first()
        )


# =====================
# QUERIES
# =====================

class Query(graphene.ObjectType):
    my_emails = graphene.List(
        EmailType,
        folder=graphene.String(default_value="inbox"),
        limit=graphene.Int(default_value=50),
        offset=graphene.Int(default_value=0),
    )

    @login_required
    def resolve_my_emails(self, info, folder, limit, offset):
        return (
            Email.objects
            .filter(user=info.context.user, folder=folder)
            .order_by("-created_at")[offset:offset + limit]
        )


# =====================
# MUTATIONS
# =====================

from emails.services import EmailCreationService

class SendEmail(graphene.Mutation):
    class Arguments:
        to = graphene.String(required=True)
        subject = graphene.String(required=True)
        body = graphene.String(required=True)

    email = graphene.Field(EmailType)

    @login_required
    def mutate(self, info, to, subject, body):
        user = info.context.user

        email = EmailCreationService.create_and_scan_email(
            user=user,
            sender=user.email,
            recipient=to,
            subject=subject,
            body=body,
            folder="sent",
            is_outgoing=True,
            service_route=info.context.service_route,
        )

        return SendEmail(email=email)

class Mutation(graphene.ObjectType):
    send_email = SendEmail.Field()
from django.db import transaction
from emails.models import Email
from scanner.models import ScanLog
from scanner.service_selector import try_real_scan, try_real_send_email
from emails.mock_service import mock_service


class EmailCreationService:
    @staticmethod
    @transaction.atomic
    def create_and_scan_email(
        *,
        user,
        sender,
        recipient,
        subject,
        body,
        folder,
        is_outgoing,
        service_route,
    ):
        # 1ï¸âƒ£ Send email (if outgoing)
        if is_outgoing:
            if service_route["mailserver"] == "real":
                try_real_send_email({
                    "to": recipient,
                    "subject": subject,
                    "body": body,
                })
            else:
                mock_service.send_email(recipient, subject, body)

        # 2ï¸âƒ£ Create Email
        email = Email.objects.create(
            user=user,
            sender=sender,
            recipient=recipient,
            subject=subject,
            body=body,
            folder=folder,
            is_outgoing=is_outgoing,
        )

        # 3ï¸âƒ£ Scan (ALWAYS)
        if service_route["scanner"] == "real":
            scan = try_real_scan(body)
        else:
            scan = mock_service.scan_email(body)

        # 4ï¸âƒ£ Persist ScanLog (ONE-TO-ONE)
        ScanLog.objects.create(
            email=email,
            user=user,
            result="malicious" if scan["malicious"] else "safe",
            confidence=scan["confidence"],
        )

        return email
from django.db.models.signals import post_save
from django.dispatch import receiver

from emails.models import Email


@receiver(post_save, sender=Email)
def email_post_save(sender, instance, created, **kwargs):
    """
    Fires when an Email is created.

    This is a DOMAIN EVENT, not a transport mechanism.
    No GraphQL subscriptions.
    No WebSockets.
    """
    if not created:
        return

    # âœ… Future-safe hooks (examples):
    # - auto scan trigger
    # - audit logging
    # - metrics
    # - notifications (later)

    # For now, do nothing
    return
from django.test import TestCase

# Create your tests here.
from django.urls import path
from .views import SendEmailMock

urlpatterns = [
    #These remain admin-only.
    path("mock/send/", SendEmailMock.as_view()),
]
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, IsAdminUser

from .mock_service import mock_service
from .models import Email
from scanner.service_selector import try_real_send_email


class SendEmailMock(APIView):
    """
    Admin-only mock email sender
    """
    permission_classes = [IsAdminUser]

    def post(self, request):
        data = mock_service.send_email(
            to=request.data.get("to", "test@example.com"),
            subject=request.data.get("subject", "Mock Email"),
            body=request.data.get("body", "")
        )
        return Response(data)


class ScanEmailMock(APIView):
    """
    Admin-only mock email scanner
    """
    permission_classes = [IsAdminUser]

    def post(self, request):
        data = mock_service.scan_email(
            request.data.get("content", "Test content")
        )
        return Response(data)

$ ls users
__init__.py
admin.py
apps.py
forms.py
migrations
models.py
serializers.py
tests.py
urls.py
views.py

$ cat users/*
from django.contrib import admin

# Register your models here.
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'users'
from django import forms
from django.contrib.auth.forms import UserCreationForm
from .models import User  # your custom user model

class CustomUserCreationForm(UserCreationForm):
    class Meta:
        model = User
        fields = ('username', 'email')  # add other fields if needed
from django.contrib.auth.models import AbstractUser
from django.db import models

class User(AbstractUser):
    ROLE_CHOICES = (
        ("admin", "Admin"),
        ("user", "User"),
    )
    role = models.CharField(max_length=10, choices=ROLE_CHOICES, default="user")
from rest_framework import serializers
from .models import User

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ["id", "username", "email", "role"]
from django.test import TestCase

# Create your tests here.
from django.urls import path
from .views import MeView, SignupAPIView

urlpatterns = [
    path("me/", MeView.as_view()),
    path("signup/", SignupAPIView.as_view()),
]
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated, AllowAny
from rest_framework import status
from django.contrib.auth import get_user_model

from .serializers import UserSerializer

User = get_user_model()


class MeView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        serializer = UserSerializer(request.user)
        return Response(serializer.data)


class SignupAPIView(APIView):
    permission_classes = [AllowAny]

    def post(self, request):
        username = request.data.get("username")
        email = request.data.get("email")
        password = request.data.get("password")

        if not username or not password:
            return Response(
                {"error": "username and password are required"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        if User.objects.filter(username=username).exists():
            return Response(
                {"error": "username already exists"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        user = User.objects.create_user(
            username=username,
            email=email,
            password=password,
        )

        return Response(
            {
                "id": user.id,
                "username": user.username,
                "email": user.email,
            },
            status=status.HTTP_201_CREATED,
        )

$ ls scanner
__init__.py
admin.py
apps.py
migrations
models.py
schema.py
service_selector.py
services.py
signals.py
tests.py
urls.py
views.py

$ cat scanner/*.py
from django.contrib import admin
from .models import ScanLog


@admin.register(ScanLog)
class ScanLogAdmin(admin.ModelAdmin):
    list_display = (
        "email_sender",
        "email_subject",
        "result",
        "confidence",
        "created_at",
    )

    list_filter = (
        "result",
        "created_at",
    )

    search_fields = (
        "email__sender",
        "email__subject",
        "email__body",
    )

    ordering = ("-created_at",)

    # -----------------------------
    # Custom display methods
    # -----------------------------
    def email_sender(self, obj):
        return obj.email.sender

    email_sender.short_description = "Sender"

    def email_subject(self, obj):
        return obj.email.subject

    email_subject.short_description = "Subject"
from django.apps import AppConfig


class ScannerConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "scanner"

    def ready(self):
        import scanner.signals  # noqa
from django.conf import settings
from django.db import models

class ScanLog(models.Model):
    email = models.OneToOneField(
        "emails.Email",
        related_name="scan",
        on_delete=models.CASCADE,
    )
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    result = models.CharField(max_length=50)
    confidence = models.FloatField()
    created_at = models.DateTimeField(auto_now_add=True)
    def __str__(self):
        return f"ScanLog for Email ID {self.email.id} - Result: {self.result}"import graphene
from graphene_django import DjangoObjectType

from backend.common.graphql_permissions import login_required, admin_required
from scanner.models import ScanLog


# =====================
# TYPES
# =====================

class ScanLogType(DjangoObjectType):
    class Meta:
        model = ScanLog
        fields = (
            "id",
            "result",
            "confidence",
            "created_at",
            "email",
        )


# =====================
# QUERIES
# =====================

class Query(graphene.ObjectType):
    scan_logs = graphene.List(
        ScanLogType,
        result=graphene.String(),
        limit=graphene.Int(default_value=50),
        offset=graphene.Int(default_value=0),
    )

    my_scan_logs = graphene.List(
        ScanLogType,
        limit=graphene.Int(default_value=50),
        offset=graphene.Int(default_value=0),
    )

    @login_required
    @admin_required
    def resolve_scan_logs(self, info, result=None, limit=50, offset=0):
        qs = ScanLog.objects.all().order_by("-created_at")
        if result:
            qs = qs.filter(result=result)
        return qs[offset:offset + limit]

    @login_required
    def resolve_my_scan_logs(self, info, limit=50, offset=0):
        return (
            ScanLog.objects
            .filter(user=info.context.user)
            .order_by("-created_at")[offset:offset + limit]
        )
import os
import requests
from emails.mock_service import mock_service

import logging
logger = logging.getLogger(__name__)

MAILSERVER_URL = os.getenv("REAL_MAILSERVER_URL")
SCANNER_URL = os.getenv("REAL_AISCANNER_URL")
USE_REAL = os.getenv("USE_REAL_SERVICES", "false").lower() == "true"


def try_real_send_email(data):
        if not USE_REAL:
                logger.warning("Real email service disabled. Using mock.")
                return mock_service.send_email(**data)

        try:
                logger.info(f"Trying real mail server at {MAILSERVER_URL}")
                response = requests.post(MAILSERVER_URL, json=data, timeout=3)
                response.raise_for_status()
                return response.json()

        except Exception as e:
                logger.error(f"Real mail server DOWN: {e}. Falling back to mock.")
                return mock_service.send_email(**data)


def try_real_scan(body):
        if not USE_REAL:
                logger.warning("Real AI scanner disabled. Using mock.")
                return mock_service.scan_email(body)

        try:
                logger.info(f"Trying real scanner at {SCANNER_URL}")
                response = requests.post(SCANNER_URL, json={"body": body}, timeout=3)
                response.raise_for_status()
                return response.json()

        except Exception as e:
                logger.error(f"AI scanner DOWN: {e}. Falling back to mock.")
                return mock_service.scan_email(body)
# scanner/services.py
import requests
from django.conf import settings

def scan_email(subject: str, body: str):
    try:
        response = requests.post(
            settings.ML_SCANNER_URL,
            json={"subject": subject, "body": body},
            timeout=3
        )
        response.raise_for_status()
        return response.json()
    except Exception:
        if settings.USE_MOCK_SCANNER:
            from scanner.mock_scanner import mock_scan
            return mock_scan(subject, body)
        raise
from django.db.models.signals import post_save
from django.dispatch import receiver

from scanner.models import ScanLog


@receiver(post_save, sender=ScanLog)
def scanlog_post_save(sender, instance, created, **kwargs):
    """
    Fires when a ScanLog is created.

    Transport-agnostic domain event.
    """
    if not created:
        return

    # âœ… Future-safe hooks:
    # - notifications
    # - risk metrics
    # - alerting
    # - async workflows

    return
from django.test import TestCase

# Create your tests here.
# scanner/urls.py
urlpatterns = []
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from emails.models import Email
from scanner.models import ScanLog
from scanner.service_selector import try_real_scan
from emails.mock_service import mock_service
from scanner.service_selector import try_real_send_email


class SendEmailView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        to = request.data.get("to")
        subject = request.data.get("subject")
        body = request.data.get("body")

        route = request.service_route.get("mailserver", "mock")

        result = (
            try_real_send_email({"to": to, "subject": subject, "body": body})
            if route == "real"
            else mock_service.send_email(to, subject, body)
        )

        Email.objects.create(
            user=request.user,
            sender=request.user.email,
            subject=subject,
            body=body,
            is_outgoing=True,
        )

        return Response({
            "status": result["status"],
            "used": route,
        })

$ ls middleware
api_key_gate.py
graphql_middleware.py
intelligent_router.py
response_logger.py
role_middleware.py
security_gateway.py

$ cat middleware/*
import os
from django.http import JsonResponse

class ApiKeyGateMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        self.valid_key = os.getenv("SCANNER_API_KEY")  # RENAMED

    def __call__(self, request):
        if request.path.startswith("/scanner/scan/"):
            provided = request.headers.get("X-API-KEY")
            if not provided or provided != self.valid_key:
                return JsonResponse({"error": "invalid or missing API key"}, status=401)

        return self.get_response(request)
from functools import wraps
import uuid

from backend.common.models import GraphQLAuditLog
from backend.common.graphql_errors import (
    AuthRequiredError,
    PermissionDeniedError,
    QueryLimitExceededError,
)


class GraphQLMiddleware:
    """
    GraphQL Middleware:
    - Reuses Django trace_id (single source of truth)
    - Enforces authentication globally
    - Enforces pagination limits
    - Stores every GraphQL operation in GraphQLAuditLog
    """

    def __init__(self, query_limit=50):
        self.query_limit = query_limit

    def resolve(self, next, root, info, **kwargs):
        request = info.context  # Django HttpRequest

        # --------------------------------------------------
        # TRACE ID (REUSE DJANGO TRACE ID)
        # --------------------------------------------------
        if hasattr(request, "trace_id"):
            trace_id = request.trace_id
        else:
            # Safety fallback (should rarely happen)
            trace_id = uuid.uuid4().hex
            request.trace_id = trace_id

        # Expose trace_id to resolvers
        info.context.trace_id = trace_id

        # --------------------------------------------------
        # AUTHENTICATION (GLOBAL)
        # --------------------------------------------------
        user = getattr(request, "user", None)
        if not user or not user.is_authenticated:
            raise AuthRequiredError()

        # --------------------------------------------------
        # QUERY LIMIT (Relay-style `first`)
        # --------------------------------------------------
        first = kwargs.get("first")
        if first is not None and first > self.query_limit:
            raise QueryLimitExceededError(self.query_limit)

        # --------------------------------------------------
        # AUDIT LOGGING
        # --------------------------------------------------
        GraphQLAuditLog.objects.create(
            trace_id=trace_id,
            user=user,
            query=str(getattr(info, "operation", None) or request.body),
            variables=kwargs,
        )

        return next(root, info, **kwargs)


# ==================================================
# FIELD-LEVEL DECORATORS (OPTIONAL OVERRIDES)
# ==================================================

def admin_required(fn):
    """
    Ensures the user is authenticated and has role='admin'
    """

    @wraps(fn)
    def wrapper(root, info, **kwargs):
        request = info.context
        user = getattr(request, "user", None)

        if not user or not user.is_authenticated:
            raise AuthRequiredError()

        if getattr(user, "role", None) != "admin":
            raise PermissionDeniedError()

        return fn(root, info, **kwargs)

    return wrapper
import time
import requests
import os

class IntelligentServiceRouterMiddleware:
    """
    Automatically selects mock vs real services for:
        - mail server
        - AI scanner
    Keeps short-term memory of service health.
    """

    def __init__(self, get_response):
        self.get_response = get_response

        # read env
        self.real_mail_url = os.getenv("REAL_MAILSERVER_URL")
        self.real_scan_url = os.getenv("REAL_AISCANNER_URL")
        self.use_real = os.getenv("USE_REAL_SERVICES", "auto").lower()

        # health memory
        self.service_status = {
            "mail": True,
            "scanner": True,
        }
        self.last_checked = { "mail": 0, "scanner": 0 }
        self.check_interval = 10  # seconds

    def check_service(self, kind, url):
        now = time.time()
        if now - self.last_checked[kind] < self.check_interval:
            return self.service_status[kind]

        self.last_checked[kind] = now

        try:
            # Prefer HEAD request
            requests.head(url, timeout=1, allow_redirects=True)
        except Exception:
            # Fallback to GET if HEAD fails
            try:
                requests.get(url, timeout=1)
            except Exception:
                self.service_status[kind] = False
                return False

        return self.service_status[kind]

    def __call__(self, request):
        """
        Decide the routing dynamically for this request.
        """

        # MAIL SERVER ROUTING
        mail_ok = self.check_service("mail", self.real_mail_url) if self.real_mail_url else False
        scanner_ok = self.check_service("scanner", self.real_scan_url) if self.real_scan_url else False

        def decide(kind, ok_flag):
            if self.use_real == "true":
                return "real" if ok_flag else "mock"
            if self.use_real == "false":
                return "mock"
            return "real" if ok_flag else "mock"

        request.service_route = {
            "mailserver": decide("mail", mail_ok),
            "scanner": decide("scanner", scanner_ok),
        }

        return self.get_response(request)
import logging
import time

logger = logging.getLogger("gateway_logger")


class ResponseLoggingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        start = time.time()
        response = self.get_response(request)
        duration_ms = round((time.time() - start) * 1000, 2)

        user = getattr(request, "user", None)

        logger.info(
            "request_completed",
            extra={
                "trace_id": getattr(request, "trace_id", None),
                "user": user.username if user and user.is_authenticated else "anon",
                "role": getattr(user, "role", None) if user else None,
                "path": request.path,
                "method": request.method,
                "status": response.status_code,
                "services": getattr(request, "service_route", {}),
                "duration_ms": duration_ms,
            },
        )

        return response
from django.http import JsonResponse

class RoleRequiredMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        required_role = getattr(request, "required_role", None)

        if required_role:
            user = request.user
            if not user.is_authenticated or user.role != required_role:
                return JsonResponse({"error": "Forbidden"}, status=403)

        return self.get_response(request)
import uuid
import time
from django.http import JsonResponse

class SecurityGatewayMiddleware:
    """
    - Enforces role-based access
    - Creates request.trace_id
    - Simple IP-based rate limiting (in-memory)
    """

    RATE_LIMIT = {}  # simple in-memory (good for dev)
    MAX_REQUESTS = 60  # per minute
    WINDOW = 60

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # 1) Trace ID for distributed logging
        request.trace_id = uuid.uuid4().hex

        # 2) Basic rate limiting (per IP)
        ip = request.META.get("REMOTE_ADDR", "unknown")
        now = time.time()

        if ip not in self.RATE_LIMIT:
            self.RATE_LIMIT[ip] = []

        self.RATE_LIMIT[ip] = [
            ts for ts in self.RATE_LIMIT[ip] if now - ts < self.WINDOW
        ]

        if len(self.RATE_LIMIT[ip]) >= self.MAX_REQUESTS:
            return JsonResponse(
                {"error": "rate limit exceeded", "trace_id": request.trace_id},
                status=429
            )

        self.RATE_LIMIT[ip].append(now)

        # 3) Role enforcement
        required_role = getattr(request, "required_role", None)

        if required_role:
            if not request.user.is_authenticated or request.user.role != required_role:
                return JsonResponse({"error": "forbidden", "trace_id": request.trace_id}, status=403)

        return self.get_response(request)

$ ls tests
README.md
conftest.py
test_api_key_auth.py
test_emails.py
test_graphql_emails.py
test_graphql_send_email.py
test_middleware.py
test_routing.py
test_scanner.py
test_users.py

$ cat tests/*
# Mercury Backend Tests

This directory contains the **full test suite** for the Mercury backend system.
Tests cover **REST APIs**, **GraphQL**, **middleware**, **service routing**, **AI scanning**, **subscriptions**, and **authentication**.

---

## Test Structure

### 1. `conftest.py`

* Provides **fixtures** for reusable test components:

  * `user` â€” Creates a test user in the database.
  * `auth_client` â€” Returns an authenticated APIClient with JWT credentials.
* Ensures **all tests requiring authentication** can reuse a single fixture.
* Automatically handles **database access** with `@pytest.mark.django_db`.

---

### 2. `test_emails.py`

**Purpose:** Test email sending functionality.

**Key Tests:**

* `test_mock_send_email()`

  * Sends a mock email.
  * Checks that the response contains `status: "sent_mock"`.
  * Verifies the `Email` object is stored in the database with `folder="sent"` and `is_outgoing=True`.

**Requirements:**

* Authenticated user via `auth_client`.
* Mock email service endpoint `/emails/mock/send/`.

---

### 3. `test_scanner.py`

**Purpose:** Test the AI scanner API.

**Key Tests:**

* `test_scan_creates_log()`

  * Sends a scan request.
  * Verifies that a `ScanLog` record is created and linked to the correct user.
  * Ensures `result` is either `"safe"` or `"malicious"`.

**Database Behavior:**

* Each scan is automatically rolled back after test completion.

---

### 4. `test_users.py`

**Purpose:** Test user authentication and profile endpoints.

**Key Tests:**

* `test_user_me()`

  * Logs in a test user.
  * Retrieves `/users/me/`.
  * Confirms the correct username is returned.

**Key Endpoints:**

* `POST /auth/token/` â€” Obtains JWT access token.
* `GET /users/me/` â€” Retrieves user profile.

---

### 5. `test_middleware.py`

**Purpose:** Test custom middleware.

**Key Tests:**

* `test_security_gateway_adds_trace_id()`

  * Ensures every request receives a unique `trace_id`.
* `test_router_sets_service_route()`

  * Confirms intelligent service routing for mock/real services.
* `test_response_logger_injects_trace()`

  * Validates that `trace_id` is injected into response JSON.

**Middleware Components:**

* `SecurityGatewayMiddleware` â€” Adds trace IDs.
* `IntelligentServiceRouterMiddleware` â€” Routes requests to mock/real services.
* `ResponseLoggingMiddleware` â€” Logs responses with trace ID.

---

### 6. `test_routing.py`

**Purpose:** Test intelligent service routing based on environment variables.

**Key Tests:**

* `test_router_mock_mode()` â€” Ensures routing goes to **mock services** if `USE_REAL_SERVICES=false`.
* `test_router_real_mode()` â€” Ensures routing goes to **real services** if `USE_REAL_SERVICES=true`.

**Environment Variables:**

* `USE_REAL_SERVICES` (`"true"`, `"false"`, `"auto"`).

---

### 7. GraphQL Tests

#### a) `test_graphql_emails.py`

* Tests **inbox query**.
* Confirms that `myEmails` query returns only the authenticated user's emails.
* Checks fields like `subject` and `folder`.

#### b) `test_graphql_send_email.py`

* Tests **sendEmail mutation**.
* Confirms that a sent email is saved correctly in the database (`folder="sent"`, `is_outgoing=True`).
* Checks that `used` field reflects the service route (`mock` or `real`).

---

### 8. Subscription Tests

#### a) `test_subscriptions.py`

* Tests **event publication** for `email_created`.
* Confirms signals are wired and Redis/GraphQL subscriptions can consume events.
* Does **not** require WebSocket or frontend clients.

---

## Running the Tests

### Run all tests:

```bash
pytest
```

### Run a specific test file:

```bash
pytest tests/test_emails.py
```

### Run a specific test function:

```bash
pytest tests/test_scanner.py::test_scan_creates_log
```

### Run with verbose output:

```bash
pytest -v
```

### Run with coverage report:

```bash
pytest --cov=.
```

### Run with Django database:

```bash
pytest --ds=backend.settings
```

---

## Test Guidelines

1. **Always use fixtures** (`auth_client`, `user`) for authentication.
2. **Mark database tests** with `@pytest.mark.django_db`.
3. **Keep tests isolated** â€” one test per functionality.
4. **Mock services** for emails and AI scanning whenever possible.
5. **GraphQL subscriptions** are tested at the event layer, not via WebSockets.

---

## Test Coverage Overview

| Test Suite     | Coverage                         |
| -------------- | -------------------------------- |
| REST Endpoints | Email, Scanner, Users            |
| Middleware     | Trace IDs, Routing, Logging      |
| Routing        | Mock/Real services               |
| GraphQL        | Inbox, SendEmail mutation        |
| Subscriptions  | Event publishing (email_created) |

---

## Notes

* All tests **rollback database changes automatically**.
* Environment variables like `USE_REAL_SERVICES` control routing during tests.
* GraphQL subscriptions require `graphene_subscriptions` and Redis configured.
* WebSocket frontend testing is **not included** in this backend suite.

---

This README is now **fully aligned** with your current backend tests, including **REST, GraphQL, middleware, routing, and subscriptions**.

---

## Test Coverage Diagram

```
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   REST Endpoints  â”‚
              â”‚ (Emails, Scanner, â”‚
              â”‚  Users API)       â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   GraphQL API     â”‚
              â”‚ (Queries, Mutationsâ”‚
              â”‚  Inbox, SendEmail)â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Subscriptions /   â”‚
              â”‚ Event Layer       â”‚
              â”‚ (email_created,   â”‚
              â”‚  scan_completed)  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Database Models   â”‚
              â”‚ (Email, ScanLog)  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚  Middleware       â”‚
              â”‚ (Security, Router,â”‚
              â”‚  Logging, API Key)â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Explanation

1. **REST Endpoints**

   * Test sending emails, scanning emails, and user endpoints.
   * Uses `APIClient` for HTTP requests.
   * Tests verify responses and database side effects.

2. **GraphQL API**

   * Tests inbox queries, `SendEmail` mutation, and permissions.
   * Uses `graphene` test client or APIClient with GraphQL POST payloads.

3. **Subscriptions / Event Layer**

   * Tests that signals/events are emitted (e.g., `email_created`, `scan_completed`).
   * Confirms that Redis/GraphQL subscription system receives events.

4. **Database Models**

   * Core tests validate `Email` and `ScanLog` creation and correctness.
   * Rollback after each test to maintain isolation.

5. **Middleware**

   * Tests ensure:

     * Trace IDs are generated (`SecurityGatewayMiddleware`)
     * Requests are routed to correct service (`IntelligentServiceRouterMiddleware`)
     * Responses log the trace (`ResponseLoggingMiddleware`)
     * API key enforcement (`ApiKeyGateMiddleware`)

---

âœ… **Key Idea:**
All tests flow **from API â†’ GraphQL â†’ Events â†’ DB â†’ Middleware**, ensuring full-stack coverage while keeping each layer testable in isolation.

---
import pytest
from rest_framework.test import APIClient
from django.contrib.auth import get_user_model

User = get_user_model()


@pytest.fixture
@pytest.mark.django_db
def user():
    return User.objects.create_user(
        username="testuser",
        email="test@test.com",
        password="password"
    )


@pytest.fixture
@pytest.mark.django_db
def auth_client(user):
    client = APIClient()
    res = client.post("/auth/token/", {
        "username": user.username,
        "password": "password"
    })
    token = res.data["access"]
    client.credentials(HTTP_AUTHORIZATION=f"Bearer {token}")
    return client
import os
import pytest
import importlib
from django.test import RequestFactory
from django.http import JsonResponse

# Import your middleware (path based on your file structure)
import middleware.api_key_gate as api_key_module


def get_response(request):
    # Simulate scanner mock/real response
    return JsonResponse({"ok": True})


@pytest.fixture
def rf():
    return RequestFactory()


# -------------------------------
# VALID API KEY
# -------------------------------
def test_api_key_valid(monkeypatch, rf):
    monkeypatch.setenv("SCANNER_API_KEY", "secret123")

    # Reload module so middleware loads updated env var
    importlib.reload(api_key_module)

    middleware = api_key_module.ApiKeyGateMiddleware(get_response)

    request = rf.post("/scanner/scan/", HTTP_X_API_KEY="secret123")
    response = middleware(request)

    assert response.status_code == 200
    assert response.json() == {"ok": True}


# -------------------------------
# MISSING API KEY
# -------------------------------
def test_api_key_missing(monkeypatch, rf):
    monkeypatch.setenv("SCANNER_API_KEY", "secret123")
    importlib.reload(api_key_module)

    middleware = api_key_module.ApiKeyGateMiddleware(get_response)

    request = rf.post("/scanner/scan/")  # No header
    response = middleware(request)

    assert response.status_code == 401
    assert "error" in response.json()
    assert response.json()["error"] == "invalid or missing API key"


# -------------------------------
# INVALID API KEY
# -------------------------------
def test_api_key_invalid(monkeypatch, rf):
    monkeypatch.setenv("SCANNER_API_KEY", "secret123")
    importlib.reload(api_key_module)

    middleware = api_key_module.ApiKeyGateMiddleware(get_response)

    request = rf.post("/scanner/scan/", HTTP_X_API_KEY="WRONG-KEY")
    response = middleware(request)

    assert response.status_code == 401
    assert response.json()["error"] == "invalid or missing API key"


# -------------------------------
# API KEY ONLY REQUIRED FOR /scanner/scan/
# -------------------------------
def test_api_key_not_required_for_other_endpoints(monkeypatch, rf):
    monkeypatch.setenv("SCANNER_API_KEY", "secret123")
    importlib.reload(api_key_module)

    middleware = api_key_module.ApiKeyGateMiddleware(get_response)

    request = rf.get("/users/me/")  # A different endpoint
    response = middleware(request)

    # Should pass without key
    assert response.status_code == 200
    assert response.json() == {"ok": True}


# -------------------------------
# KEY IS READ FROM ENV AT INIT
# -------------------------------
def test_api_key_caching(monkeypatch, rf):
    monkeypatch.setenv("SCANNER_API_KEY", "initial")
    importlib.reload(api_key_module)

    middleware = api_key_module.ApiKeyGateMiddleware(get_response)

    # Change ENV after initialization (should not affect middleware)
    monkeypatch.setenv("SCANNER_API_KEY", "new-value")

    request = rf.post("/scanner/scan/", HTTP_X_API_KEY="initial")
    response = middleware(request)

    assert response.status_code == 200
import pytest
from emails.models import Email


@pytest.mark.django_db
def test_mock_send_email(auth_client, user):
    res = auth_client.post("/emails/mock/send/", {
        "to": "a@b.com",
        "subject": "Hi",
        "body": "Test"
    })

    assert res.status_code == 200
    assert res.data["status"] == "sent_mock"

    assert Email.objects.count() == 1
    email = Email.objects.first()
    assert email.folder == "sent"
    assert email.is_outgoing is True
import pytest
from emails.models import Email


@pytest.mark.django_db
def test_graphql_inbox_query(client, user):
    Email.objects.create(
        user=user,
        sender="x@test.com",
        recipient=user.email,
        subject="Inbox mail",
        body="Hello",
        folder="inbox",
    )

    query = """
    query {
      myEmails {
        subject
        folder
      }
    }
    """

    client.force_login(user)
    res = client.post("/graphql/", {"query": query})

    assert res.status_code == 200
    data = res.json()["data"]["myEmails"]
    assert len(data) == 1
    assert data[0]["folder"] == "inbox"
import pytest
from emails.models import Email


@pytest.mark.django_db
def test_graphql_send_email(client, user):
    mutation = """
    mutation {
      sendEmail(to: "x@test.com", subject: "Hi", body: "Hello") {
        used
        email {
          subject
          folder
        }
      }
    }
    """

    client.force_login(user)
    res = client.post("/graphql/", {"query": mutation})

    assert res.status_code == 200
    payload = res.json()["data"]["sendEmail"]

    assert payload["email"]["folder"] == "sent"
    assert Email.objects.count() == 1
import uuid
import pytest
from django.test import RequestFactory
from django.http import JsonResponse
from django.contrib.auth.models import AnonymousUser

from middleware.security_gateway import SecurityGatewayMiddleware
from middleware.intelligent_router import IntelligentServiceRouterMiddleware
from middleware.response_logger import ResponseLoggingMiddleware

def get_response(_):
    return JsonResponse({"ok": True})

def test_security_gateway_adds_trace_id():
    request = RequestFactory().get("/scanner/scan/")
    mw = SecurityGatewayMiddleware(get_response)

    response = mw(request)

    assert hasattr(request, "trace_id")
    assert isinstance(uuid.UUID(request.trace_id), uuid.UUID)

def test_router_sets_service_route():
    request = RequestFactory().post("/scanner/scan/")
    mw = IntelligentServiceRouterMiddleware(get_response)
    response = mw(request)

    assert hasattr(request, "service_route")
    assert "scanner" in request.service_route
    assert request.service_route["scanner"] in ["mock", "real"]

def test_response_logger_injects_trace():
    request = RequestFactory().get("/")
    request.trace_id = "1234-TEST"
    request.user = AnonymousUser()  # FIX

    mw = ResponseLoggingMiddleware(get_response)
    response = mw(request)

    assert "trace_id" in response.json()
import os
import importlib
import pytest
from django.test import RequestFactory
from middleware import intelligent_router as router

def get_response(request):
    return None

def test_router_mock_mode(monkeypatch):
    monkeypatch.setenv("USE_REAL_SERVICES", "false")
    importlib.reload(router)  # reload to pick up env var

    request = RequestFactory().get("/")
    mw = router.IntelligentServiceRouterMiddleware(get_response)
    mw(request)

    assert request.service_route["scanner"] == "mock"

def test_router_real_mode(monkeypatch):
    monkeypatch.setenv("USE_REAL_SERVICES", "true")
    importlib.reload(router)  # reload to pick up env var

    request = RequestFactory().get("/")
    mw = router.IntelligentServiceRouterMiddleware(get_response)
    mw(request)

    assert request.service_route["scanner"] == "real"
import pytest
from scanner.models import ScanLog
from emails.models import Email


@pytest.mark.django_db
def test_scan_creates_log(auth_client, user):
    email = Email.objects.create(
        user=user,
        sender="a@test.com",
        recipient=user.email,
        subject="Hello",
        body="Hello world",
        folder="inbox",
    )

    # Scan happens via signal in real flow,
    # but REST scan endpoint still allowed
    res = auth_client.post("/scanner/scan/", {
        "body": email.body
    })

    assert res.status_code == 200
    assert ScanLog.objects.count() == 1

    log = ScanLog.objects.first()
    assert log.user == user
    assert log.result in ["safe", "malicious"]
import pytest
from rest_framework.test import APIClient
from django.contrib.auth import get_user_model

User = get_user_model()

@pytest.mark.django_db
def test_user_me():
    user = User.objects.create_user("john", "j@j.com", "pass")
    client = APIClient()

    token = client.post("/auth/token/", {"username": "john", "password": "pass"}).data["access"]
    client.credentials(HTTP_AUTHORIZATION=f"Bearer {token}")

    res = client.get("/users/me/")
    assert res.status_code == 200
    assert res.data["username"] == "john"

$ ls realtime
__init__.py
admin.py
apps.py
consumers.py
migrations
models.py
routing.py
tests.py
views.py

$ cat realtime/*
from django.contrib import admin

# Register your models here.
from django.apps import AppConfig


class RealtimeConfig(AppConfig):
    name = 'realtime'
import json
from channels.generic.websocket import AsyncWebsocketConsumer

class EventConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        user = self.scope["user"]

        if not user.is_authenticated:
            await self.close()
            return

        self.group_name = f"user_{user.id}"

        await self.channel_layer.group_add(
            self.group_name,
            self.channel_name,
        )

        await self.accept()

    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(
            self.group_name,
            self.channel_name,
        )

    async def send_event(self, event):
        await self.send(text_data=json.dumps(event["data"]))
from django.db import models

# Create your models here.
from django.urls import path
from .consumers import EventConsumer

websocket_urlpatterns = [
    path("ws/events/", EventConsumer.as_asgi()),
]
from django.test import TestCase

# Create your tests here.
from django.shortcuts import render

# Create your views here.

$ ls backend
__init__.py
asgi.py
common
schema.py
settings.py
urls.py
wsgi.py

$ cat backend/*.py
import os
import django
from channels.routing import ProtocolTypeRouter, URLRouter
from django.core.asgi import get_asgi_application
from channels.auth import AuthMiddlewareStack

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "backend.settings")
django.setup()

import realtime.routing  # NEW

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": AuthMiddlewareStack(
        URLRouter(
            realtime.routing.websocket_urlpatterns
        )
    ),
})
import graphene
import graphql_jwt

from emails.schema import (
    Query as EmailQuery,
    Mutation as EmailMutation,
)

from scanner.schema import Query as ScannerQuery


# =====================
# ROOT QUERY
# =====================
class Query(
    EmailQuery,
    ScannerQuery,
    graphene.ObjectType,
):
    """
    Frontend-facing GraphQL queries:
    - Inbox emails
    - Scan logs
    """
    pass


# =====================
# ROOT MUTATION
# =====================
class Mutation(
    EmailMutation,
    graphene.ObjectType,
):
    """
    Frontend-facing GraphQL mutations:
    - sendEmail
    - JWT authentication
    """

    token_auth = graphql_jwt.ObtainJSONWebToken.Field()
    verify_token = graphql_jwt.Verify.Field()
    refresh_token = graphql_jwt.Refresh.Field()


# =====================
# SCHEMA
# =====================
schema = graphene.Schema(
    query=Query,
    mutation=Mutation,
)
"""
Django settings for backend project.

Generated by 'django-admin startproject' using Django 5.2.8.
"""

from pathlib import Path
import os
from corsheaders.defaults import default_headers

# =====================
# BASE DIR
# =====================
BASE_DIR = Path(__file__).resolve().parent.parent


# =====================
# SECURITY
# =====================
SECRET_KEY = os.environ.get(
    "DJANGO_SECRET_KEY",
    "django-insecure-change-me-in-production"
)

DEBUG = True

ALLOWED_HOSTS = ["*"]


# =====================
# APPLICATIONS
# =====================
INSTALLED_APPS = [
    # CORS (MUST BE FIRST APP)
    "corsheaders",

    # Django core
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",

    # Third-party
    "rest_framework",
    "rest_framework_simplejwt",
    "drf_yasg",
    "graphene_django",
    "graphql_jwt",  # âœ… ADD THIS

    # Local apps
    "users",
    "emails.apps.EmailsConfig",
    "scanner.apps.ScannerConfig",
    "backend.common",
]


# =====================
# MIDDLEWARE
# =====================
MIDDLEWARE = [
    # CORS (MUST BE FIRST MIDDLEWARE)
    "corsheaders.middleware.CorsMiddleware",

    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",

    "django.contrib.auth.middleware.AuthenticationMiddleware",

    # Custom gateway logic
    "middleware.security_gateway.SecurityGatewayMiddleware",
    "middleware.api_key_gate.ApiKeyGateMiddleware",
    "middleware.intelligent_router.IntelligentServiceRouterMiddleware",
    "middleware.response_logger.ResponseLoggingMiddleware",

    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]


# =====================
# URL / TEMPLATES
# =====================
ROOT_URLCONF = "backend.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]


# =====================
# WSGI (HTTP ONLY)
# =====================
WSGI_APPLICATION = "backend.wsgi.application"


# =====================
# DATABASE
# =====================
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": os.environ.get("POSTGRES_DB", "postgres"),
        "USER": os.environ.get("POSTGRES_USER", "postgres"),
        "PASSWORD": os.environ.get("POSTGRES_PASSWORD", "postgres"),
        "HOST": os.environ.get("POSTGRES_HOST", "db"),
        "PORT": os.environ.get("POSTGRES_PORT", 5432),
    }
}


# =====================
# AUTH / PASSWORDS
# =====================
AUTH_PASSWORD_VALIDATORS = [
    {"NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator"},
    {"NAME": "django.contrib.auth.password_validation.MinimumLengthValidator"},
    {"NAME": "django.contrib.auth.password_validation.CommonPasswordValidator"},
    {"NAME": "django.contrib.auth.password_validation.NumericPasswordValidator"},
]

AUTH_USER_MODEL = "users.User"


# =====================
# INTERNATIONALIZATION
# =====================
LANGUAGE_CODE = "en-us"
TIME_ZONE = "UTC"
USE_I18N = True
USE_TZ = True


# =====================
# STATIC FILES
# =====================
STATIC_URL = "static/"


# =====================
# DEFAULT PK
# =====================
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"


# =====================
# DRF / JWT
# =====================
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": (
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ),
}


LOGIN_REDIRECT_URL = "/"
LOGOUT_REDIRECT_URL = "/login/"


# =====================
# GRAPHQL (Graphene)
# =====================
GRAPHENE = {
    "SCHEMA": "backend.schema.schema",
    "MIDDLEWARE": [
        # "graphql_jwt.middleware.JSONWebTokenMiddleware",
        "middleware.graphql_middleware.GraphQLMiddleware",
    ],
}


# =====================
# CORS CONFIGURATION
# =====================

# DEV MODE (browser access allowed from anywhere)
CORS_ALLOW_ALL_ORIGINS = True

# Allow cookies / Authorization headers
CORS_ALLOW_CREDENTIALS = True

# Explicitly allow JWT Authorization header
CORS_ALLOW_HEADERS = list(default_headers) + [
    "authorization",
]


# =====================
# LOGGING
# =====================
LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,

    "formatters": {
        "json": {
            "()": "pythonjsonlogger.jsonlogger.JsonFormatter",
            "fmt": "%(asctime)s %(levelname)s %(name)s %(message)s",
        }
    },

    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "json",
        }
    },

    "root": {
        "handlers": ["console"],
        "level": "INFO",
    },

    "loggers": {
        "gateway_logger": {
            "handlers": ["console"],
            "level": "INFO",
            "propagate": False,
        }
    },
}

AUTHENTICATION_BACKENDS = [
    # "graphql_jwt.backends.JSONWebTokenBackend",
    "django.contrib.auth.backends.ModelBackend",
]

ML_SCANNER_URL = "http://ml_scanner:8000/scan"
USE_MOCK_SCANNER = False
from django.contrib import admin
from django.urls import path, include
from django.views.decorators.csrf import csrf_exempt
from django.conf import settings

from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)
from rest_framework_simplejwt.authentication import JWTAuthentication

from drf_yasg.views import get_schema_view
from drf_yasg import openapi
from rest_framework import permissions

from graphene_django.views import GraphQLView

from backend.schema import schema


schema_view = get_schema_view(
    openapi.Info(title="Mock Backend API", default_version="v1"),
    public=True,
    permission_classes=(permissions.AllowAny,),
)


# =========================
# JWT-AWARE GRAPHQL VIEW
# =========================
class PrivateGraphQLView(GraphQLView):
    def dispatch(self, request, *args, **kwargs):
        """
        Manually authenticate the user using SimpleJWT
        so GraphQL has access to request.user
        """
        jwt_auth = JWTAuthentication()

        try:
            auth_result = jwt_auth.authenticate(request)
        except Exception:
            auth_result = None

        if auth_result is not None:
            request.user, request.auth = auth_result

        return super().dispatch(request, *args, **kwargs)


urlpatterns = [
    # Admin
    path("admin/", admin.site.urls),

    # JWT Auth (API)
    path("auth/token/", TokenObtainPairView.as_view()),
    path("auth/token/refresh/", TokenRefreshView.as_view()),

    # App APIs
    path("users/", include("users.urls")),
    path("emails/", include("emails.urls")),

    # API Docs
    path("swagger/", schema_view.with_ui("swagger", cache_timeout=0)),

    # GraphQL (JWT protected)
    path(
        "graphql/",
        csrf_exempt(
            PrivateGraphQLView.as_view(
                schema=schema,
                graphiql=settings.DEBUG,  # dev only
            )
        ),
    ),
]
"""
WSGI config for backend project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

application = get_wsgi_application()

$ ls backend/common
__init__.py
admin.py
apps.py
audit_logger.py
graphql_auth.py
graphql_errors.py
graphql_permissions.py
migrations
models.py

$ cat backend/common/*
# backend/common/admin.py
from django.contrib import admin
from backend.common.models import GraphQLAuditLog

@admin.register(GraphQLAuditLog)
class GraphQLAuditLogAdmin(admin.ModelAdmin):
    list_display = ("created_at", "user", "trace_id")
    search_fields = ("trace_id", "query")
    ordering = ("-created_at",)
from django.apps import AppConfig


class CommonConfig(AppConfig):
    name = "backend.common"
    label = "common"
# # backend/common/audit_logger.py
# import logging

# logger = logging.getLogger("audit_logger")

# def log_graphql_event(trace_id, user, operation, variables):
#     logger.info(f"[{trace_id}] user={user.username if user else 'anon'} op={operation} vars={variables}")
# This file is ONLY for GraphQL permission helpers

def require_admin(user):
    if not user or not user.is_authenticated:
        raise Exception("Authentication required")

    if user.role != "admin":
        raise Exception("Admins only")
from graphql import GraphQLError


class AuthRequiredError(GraphQLError):
    def __init__(self):
        super().__init__(
            message="Authentication required",
            extensions={
                "code": "AUTH_REQUIRED"
            }
        )


class PermissionDeniedError(GraphQLError):
    def __init__(self):
        super().__init__(
            message="Permission denied",
            extensions={
                "code": "PERMISSION_DENIED"
            }
        )


class QueryLimitExceededError(GraphQLError):
    def __init__(self, limit):
        super().__init__(
            message=f"Query limit exceeded (max {limit})",
            extensions={
                "code": "QUERY_LIMIT_EXCEEDED",
                "max_limit": limit,
            }
        )
from functools import wraps

from backend.common.graphql_errors import (
    AuthRequiredError,
    PermissionDeniedError,
)


def login_required(fn):
    """
    Ensures the user is authenticated in GraphQL resolvers
    """

    @wraps(fn)
    def wrapper(*args, **kwargs):
        info = args[1]  # (root/self, info, ...)
        user = getattr(info.context, "user", None)

        if not user or not user.is_authenticated:
            raise AuthRequiredError()

        return fn(*args, **kwargs)

    return wrapper


def admin_required(fn):
    """
    Ensures the user is authenticated AND has role='admin'
    """

    @wraps(fn)
    def wrapper(*args, **kwargs):
        info = args[1]
        user = getattr(info.context, "user", None)

        if not user or not user.is_authenticated:
            raise AuthRequiredError()

        if getattr(user, "role", None) != "admin":
            raise PermissionDeniedError()

        return fn(*args, **kwargs)

    return wrapper
from django.conf import settings
from django.db import models


class GraphQLAuditLog(models.Model):
    trace_id = models.CharField(max_length=64, db_index=True)
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        null=True,
        blank=True,
        on_delete=models.SET_NULL,
    )
    query = models.TextField()
    variables = models.JSONField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"GraphQLAuditLog(trace_id={self.trace_id})"

==============================
END OF DUMP
