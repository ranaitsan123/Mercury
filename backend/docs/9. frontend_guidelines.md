# Mercury Frontend Architecture Guide

This document explains how the frontend should be structured to integrate with the Mercury backend. It includes component design, data flow, and interactions with GraphQL queries, mutations, and subscriptions.

---

## 1. Architecture Overview

The frontend should follow a **modular component-based architecture** (React, Vue, or similar). Key responsibilities:

1. **Display Emails** – Inbox and Sent items.
2. **Real-time Updates** – Show newly received or sent emails automatically.
3. **Scan Results** – Display AI scan status and confidence.
4. **Authentication** – Handle JWT login and include tokens in GraphQL requests.

**High-level Data Flow:**

```

User Action --> GraphQL Query/Mutation --> Backend --> Database + AI Scanner
Backend Subscriptions --> Frontend Listeners --> Update UI

```

**Notes:**
- Users never trigger scans manually. All scans are automatic.
- Backend decides whether services are `mock` (dev) or `real` (prod).

---

## 2. Component Structure

### 2.1 Pages / Views

1. **InboxPage**
   - Shows all incoming emails.
   - Uses `myEmails(folder: "inbox")` query.
   - Listens to `emailCreated` subscription for real-time updates.

2. **SentPage**
   - Shows all sent emails.
   - Uses `myEmails(folder: "sent")` query.
   - Optionally subscribe to `emailCreated` to confirm sent emails.

3. **EmailDetailModal**
   - Displays full email content.
   - Shows `scan.result` and `scan.confidence`.

4. **SendEmailForm**
   - Allows sending new emails via `sendEmail` mutation.
   - Backend handles ScanLog automatically.
   - Show feedback for `used` route (mock/real).

---

### 2.2 Components

| Component          | Description |
|-------------------|------------|
| `EmailList`        | Reusable component for displaying a list of emails with scan results. |
| `EmailItem`        | Individual email card showing sender, subject, and scan badge. |
| `ScanBadge`        | Displays `safe` or `malicious` with confidence percentage. |
| `SubscriptionHandler` | Central listener for GraphQL subscriptions (`emailCreated`, `scanCompleted`). |

---

## 3. GraphQL Integration

### 3.1 Queries

- `myEmails(folder, limit, offset)`  
  Fetch emails for the authenticated user with pagination.

**Frontend Notes:**
- Call once when page loads.
- Use `offset` + `limit` for infinite scroll or pagination.

---

### 3.2 Mutations

- `sendEmail(to, subject, body)`  
  Sends a new email. Backend automatically scans and creates ScanLog.

**Frontend Notes:**
- After sending, optionally update inbox/sent cache or wait for `emailCreated` subscription.
- Display success/failure based on backend response.

---

### 3.3 Subscriptions

- `emailCreated`  
  Listen to new emails (incoming or sent).
- `scanCompleted` (optional)  
  Update scan status in UI asynchronously.

**Frontend Notes:**
- Maintain a central subscription manager to handle events.
- Update relevant components via state management (Redux, Context API, Vuex, Pinia, etc.).

---

## 4. State Management

Suggested approach:

- **EmailsStore**
  - `inboxEmails: []`
  - `sentEmails: []`
  - `updateEmail(email)` – update an email after subscription triggers.
- **ScanStore** (optional)
  - Map email IDs → scan results.
  - Can be merged with EmailsStore for simplicity.

---

## 5. Authentication

- Use JWT tokens from backend `/auth/token/`.
- Include in GraphQL headers:

```

Authorization: Bearer <ACCESS_TOKEN>

```

- Store token securely (memory, context, or secure storage; avoid localStorage if possible).

---

## 6. Error Handling

- Backend may return `mock` or `real` for email routes.
- Handle GraphQL errors and network failures gracefully.
- Show loading states for subscriptions and mutations.

---

## 7. Development Best Practices

1. **Use Apollo Client or urql** for GraphQL integration.
2. **Centralize subscriptions** to avoid multiple listeners for the same event.
3. **Normalize data** – maintain a single source of truth for emails and scan results.
4. **UI indicators** – show scan results clearly, highlight malicious emails.
5. **Environment-aware** – use mock endpoints in development, real endpoints in production.
6. **Do not implement manual scanning** – all scanning is automatic in the backend.

---

## 8. Recommended Workflow

1. On page load, query emails with `myEmails`.
2. Subscribe to `emailCreated` for real-time updates.
3. Use `sendEmail` mutation for sending new emails.
4. Update local state when subscription events arrive.
5. Render emails with scan badges (`safe`/`malicious`) and confidence.
6. Support pagination with `limit` and `offset`.

---

This structure ensures:

- Tight integration with the backend.
- Automatic scanning workflow without user intervention.
- Real-time updates and consistent inbox/sent views.
