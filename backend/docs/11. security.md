# Mercury Backend Security Documentation

This document provides an overview of the security mechanisms implemented in the Mercury backend system. It describes authentication, authorization, API key management, service isolation, and best practices to ensure secure operation.

---

## 1. Authentication

The system uses **JWT (JSON Web Token)** for user authentication.

- **Login Flow:**
  1. User submits credentials to `/auth/token/` endpoint.
  2. Backend validates credentials.
  3. Backend returns a JWT token (access + refresh).
  4. Client includes the token in `Authorization` header for subsequent requests:

```http
Authorization: Bearer <access_token>
````

* **Key Points:**

  * Tokens expire after a defined time period (configurable in settings).
  * Refresh tokens can be used to obtain new access tokens.
  * All sensitive endpoints require authentication via `@login_required` decorator.

---

## 2. Authorization

Authorization is role-based:

* **Regular Users**

  * Access only their own emails and scan logs.
  * Cannot perform administrative actions.

* **Admins**

  * Access all scan logs.
  * Can perform administrative queries or mutations.

* Decorators used:

  * `@login_required` – ensures request has a valid user.
  * `@admin_required` – ensures request user has admin privileges.

---

## 3. API Key Protection

Certain endpoints (e.g., `/scanner/scan/`) require **API key verification**:

* API keys are stored in environment variables (`MAILSERVER_API_KEY`).
* Middleware (`ApiKeyGateMiddleware`) validates incoming requests:

```http
X-API-KEY: <your_api_key>
```

* Requests without a valid API key receive **401 Unauthorized**.
* API keys are cached at middleware initialization to avoid runtime env access overhead.

---

## 4. Service Isolation and Routing

The backend routes requests between **mock** and **real services**:

* Controlled by `USE_REAL_SERVICES` environment variable:

  * `true` – use real services (mailserver, AI scanner).
  * `false` – use mock services for development/testing.
  * `auto` – dynamically chooses service based on environment.
* Ensures that sensitive operations like sending real emails or scanning are gated and controlled.

---

## 5. Data Protection

* **Password Storage:** Uses Django’s built-in password hashing (PBKDF2 by default).
* **Sensitive Data:** Emails, scan logs, and API keys are never logged in plaintext.
* **Database Access:** Only the backend has direct DB access; connections are secured via username/password and host restrictions.

---

## 6. Transport Security

* Production deployments must use **HTTPS** to protect data in transit.
* WebSocket subscriptions (GraphQL subscriptions) should also be secured with `wss://`.

---

## 7. Middleware Security Layers

* **SecurityGatewayMiddleware**

  * Adds a unique `trace_id` to each request for tracking.
* **IntelligentServiceRouterMiddleware**

  * Ensures requests are routed correctly to mock or real services, preventing accidental exposure.
* **ResponseLoggingMiddleware**

  * Logs responses safely without exposing sensitive data.

---

## 8. GraphQL Security Considerations

* All mutations that modify data require authentication.
* Unauthorized users cannot access or mutate other users’ emails or scan logs.
* Subscriptions are only triggered for authenticated users and filter results by user.

---

## 9. Best Practices for Secure Usage

* Keep `DJANGO_SECRET_KEY` and API keys secret.
* Rotate API keys regularly.
* Always deploy behind a reverse proxy with HTTPS.
* Monitor logs for unusual activity.
* Limit database access to backend servers only.
* Avoid exposing mock endpoints in production.

---

## 10. Summary

The Mercury backend employs:

* JWT authentication and role-based authorization.
* API key protection for sensitive endpoints.
* Service isolation between real and mock services.
* Data protection, secure transport, and logging hygiene.
* Middleware layers to ensure traceability and secure request routing.

Following these guidelines ensures a secure and reliable backend service.

