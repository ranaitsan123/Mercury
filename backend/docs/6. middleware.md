# Mercury Backend Signals Documentation

This document explains all Django signals used in the Mercury backend. Signals are used to automatically trigger actions when certain events happen, like email creation or scan completion.

---

## 1. Overview

**Purpose of Signals:**

- Decouple business logic from model operations.
- Automatically trigger scanning for incoming/outgoing emails.
- Notify subscribers (GraphQL subscriptions) about changes in real-time.

**Key Events:**

1. **Email Creation** – Trigger scan automatically.
2. **Scan Completion** – Notify frontend subscribers.

---

## 2. Email Signals

### 2.1 `post_save` for Email Model

**File:** `emails/signals.py`

**Description:**

- Triggered whenever a new `Email` instance is created.
- Sends the email to the AI scanner automatically (no user action required).
- Updates the `ScanLog` with results.
- Fires GraphQL subscriptions for real-time updates.

**Implementation:**

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from emails.models import Email
from scanner.models import ScanLog
from scanner.service_selector import try_real_scan
from emails.mock_service import mock_service
from graphene_subscriptions.signals import post_save_subscription

@receiver(post_save, sender=Email)
def auto_scan_email(sender, instance, created, **kwargs):
    if created and not instance.is_outgoing:  # Scan only incoming emails automatically
        route = getattr(instance, "service_route", {}).get("scanner", "mock")

        if route == "real":
            scan_result = try_real_scan(instance.body)
        else:
            scan_result = mock_service.scan_email(instance.body)

        # Create ScanLog
        ScanLog.objects.create(
            user=instance.user,
            sender=instance.sender,
            subject=instance.subject,
            body=instance.body,
            result="malicious" if scan_result["malicious"] else "safe",
            confidence=scan_result["confidence"],
        )

        # Trigger GraphQL subscription
        post_save_subscription.send(sender=Email, instance=instance)
````

**Notes:**

* `is_outgoing=True` emails are also scanned automatically after sending.
* `post_save_subscription` is used to notify GraphQL subscription listeners.

---

## 3. ScanLog Signals

### 3.1 `post_save` for ScanLog Model

**File:** `scanner/signals.py`

**Description:**

* Optional: fires when a new scan log is created.
* Can notify frontend clients about scan completion via `scanCompleted` subscription.

**Implementation:**

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from scanner.models import ScanLog
from graphene_subscriptions.signals import post_save_subscription

@receiver(post_save, sender=ScanLog)
def notify_scan_completed(sender, instance, created, **kwargs):
    if created:
        post_save_subscription.send(sender=ScanLog, instance=instance)
```

**Notes:**

* Helps frontend update email scan status in real-time.
* Works with any UI component listening to the `scanCompleted` subscription.

---

## 4. Best Practices

* **Always check `created`** flag to avoid running logic on updates.
* **Avoid user-triggered scans**; the system handles scanning automatically.
* **Use `post_save_subscription`** to notify GraphQL clients.
* Keep signal logic minimal; delegate heavy processing to services.

---

## 5. GraphQL Integration

| Signal              | GraphQL Subscription | Frontend Effect                                |
| ------------------- | -------------------- | ---------------------------------------------- |
| `Email.post_save`   | `emailCreated`       | Updates inbox/sent lists in real-time          |
| `ScanLog.post_save` | `scanCompleted`      | Updates email scan badges (`safe`/`malicious`) |

---

This structure ensures automatic scanning and real-time notifications without requiring user actions, keeping frontend and backend perfectly aligned.

