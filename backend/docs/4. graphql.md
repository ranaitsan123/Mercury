# Mercury Backend GraphQL API

This document explains the GraphQL API endpoints exposed by the Mercury backend. Frontend developers can use this as a reference to query emails, send messages, and subscribe to updates.

---

## 1. Queries

### 1.1 Fetch User Emails

**Query:** `myEmails`

**Purpose:**  
Retrieve emails for the authenticated user. Supports inbox and sent folders with pagination.

**Arguments:**

| Name   | Type   | Default | Description |
|--------|--------|---------|------------|
| folder | String | `"inbox"` | Filter emails by folder (`"inbox"` or `"sent"`) |
| limit  | Int    | `50`    | Maximum number of emails to return |
| offset | Int    | `0`     | Pagination offset |

**Example Query:**
```graphql
query {
  myEmails(folder: "inbox", limit: 10, offset: 0) {
    id
    sender
    recipient
    subject
    body
    folder
    createdAt
    scan {
      result
      confidence
    }
  }
}
````

**Notes for Frontend:**

* `scan` contains automatic AI scan results.
* `folder` determines if the email is inbox or sent.
* Use `limit` and `offset` for pagination.

---

## 2. Mutations

### 2.1 Send an Email

**Mutation:** `sendEmail`

**Purpose:**
Send a new email. The backend automatically creates a ScanLog after sending.

**Arguments:**

| Name    | Type   | Required | Description             |
| ------- | ------ | -------- | ----------------------- |
| to      | String | ✅        | Recipient email address |
| subject | String | ✅        | Email subject           |
| body    | String | ✅        | Email content           |

**Example Mutation:**

```graphql
mutation {
  sendEmail(to: "friend@example.com", subject: "Hello", body: "How are you?") {
    email {
      id
      sender
      recipient
      subject
      body
      folder
      createdAt
      scan {
        result
        confidence
      }
    }
    used
  }
}
```

**Notes:**

* `used` indicates whether the backend used `mock` or `real` mail service.
* `scan` field is automatically populated after backend scanning.

---

## 3. Subscriptions

### 3.1 New Email Created

**Subscription:** `emailCreated`

**Purpose:**
Notify frontend in real-time when a new email is created for the user (incoming or sent).

**Example Subscription:**

```graphql
subscription {
  emailCreated {
    id
    sender
    recipient
    subject
    body
    folder
    createdAt
    scan {
      result
      confidence
    }
  }
}
```

**Notes:**

* Only receives emails relevant to the authenticated user.
* Scan results will appear once the backend AI scanning is complete.
* Ideal for inbox auto-refresh or notifications.

---

### 3.2 Scan Completed (Optional)

**Subscription:** `scanCompleted`

**Purpose:**
Notify frontend when an email scan is finished.

**Example Subscription:**

```graphql
subscription {
  scanCompleted {
    id
    result
    confidence
    email {
      id
      subject
      sender
    }
  }
}
```

**Notes:**

* Allows frontend to update UI with scan status asynchronously.
* Useful for displaying “safe” or “malicious” tags in real-time.

---

## 4. Authentication

* All queries, mutations, and subscriptions require **JWT authentication**.
* Include the header:

```
Authorization: Bearer <ACCESS_TOKEN>
```

* Tokens can be obtained via backend `/auth/token/` endpoint.

---

## 5. Pagination & Filtering

* Use `limit` and `offset` in queries to paginate large datasets.
* Use `folder` in `myEmails` to distinguish between inbox and sent items.
* Filtering for scans by result (safe/malicious) can be added via backend GraphQL queries if needed.

---

## 6. Best Practices for Frontend

1. Always subscribe to `emailCreated` for real-time updates.
2. Display `scan.result` and `scan.confidence` for each email.
3. Use `folder` to separate inbox and sent emails in the UI.
4. Do **not** attempt to send scans manually; all scans are automatic.
5. Handle both `mock` and `real` routes in development and production.

---

This API design ensures that:

* Emails and scans are fully synchronized with the backend.
* Frontend receives automatic updates without polling.
* Inbox and sent views are consistent with the backend state.

