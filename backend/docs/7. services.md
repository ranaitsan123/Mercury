# Mercury Backend Services Documentation

This document explains the services used in the Mercury backend. Services are external or internal components responsible for executing specific business logic, such as sending emails or scanning content.

---

## 1. Overview

The backend is designed around service abstractions to support **mock** and **real** implementations:

- **Mock services** – for development and testing.
- **Real services** – for production use.

Service routing is automatically handled by the **Intelligent Service Router Middleware** (`request.service_route`).

Current services:

1. **Email Service**
2. **AI Scanner Service**

---

## 2. Email Service

**Purpose:**

- Send emails to recipients.
- Track outgoing messages in the database.

**Service Routing:**

- `"mock"` → `emails.mock_service`
- `"real"` → `scanner.service_selector.try_real_send_email`

**Mock Service Example:**

```python
# emails/mock_service.py
class MockEmailService:
    @staticmethod
    def send_email(to, subject, body):
        # Simulate sending email without actual delivery
        return {"status": "sent_mock"}
````

**Real Service Example:**

```python
# scanner/service_selector.py
def try_real_send_email(payload):
    # Integrates with actual mailserver
    # payload = {"to": ..., "subject": ..., "body": ...}
    # Returns {"status": "sent"}
    ...
```

**Frontend Integration:**

* Use GraphQL mutation `sendEmail(to, subject, body)` to send messages.
* System automatically routes the request to mock/real service.
* Emails are recorded in the backend database for later queries (`myEmails`).

---

## 3. AI Scanner Service

**Purpose:**

* Automatically scan all incoming and outgoing emails.
* Detect malicious content and compute confidence scores.
* Create `ScanLog` records for each email.

**Service Routing:**

* `"mock"` → `emails.mock_service.scan_email`
* `"real"` → `scanner.service_selector.try_real_scan`

**Mock Service Example:**

```python
# emails/mock_service.py
class MockEmailService:
    @staticmethod
    def scan_email(body):
        return {"malicious": False, "confidence": 0.0}
```

**Real Service Example:**

```python
# scanner/service_selector.py
def try_real_scan(email_body):
    # Sends email content to AI scanning engine
    # Returns {"malicious": True/False, "confidence": float}
    ...
```

**Frontend Integration:**

* **No frontend action required.**
* The system automatically scans all emails after sending or receiving.
* Use `myEmails` query to retrieve emails and the embedded `scan` field for results.

---

## 4. Service Contracts

| Service                   | Input                   | Output                                            | Notes                            |
| ------------------------- | ----------------------- | ------------------------------------------------- | -------------------------------- |
| Email Service (mock/real) | `to`, `subject`, `body` | `{"status": "sent"}` or `{"status": "sent_mock"}` | Sends or simulates sending email |
| AI Scanner (mock/real)    | `body`                  | `{"malicious": bool, "confidence": float}`        | Automatic scanning of all emails |

---

## 5. Service Usage in Backend

* Services are **not called directly by frontend**; the backend exposes GraphQL endpoints.
* Services are selected dynamically by `request.service_route` middleware.
* `ScanLog` and `Email` models persist results for queries and subscriptions.

**Example Workflow:**

1. User sends email via `sendEmail` mutation.
2. Middleware sets `service_route` (`mock` or `real`).
3. Email service sends the message.
4. AI Scanner automatically scans the email body.
5. `ScanLog` entry is created with results.
6. Frontend can query `myEmails` → each email includes `scan` data.

---

## 6. Best Practices

1. **Always route via service middleware** – ensures proper mock/real separation.
2. **Do not call services directly from frontend** – use GraphQL mutations.
3. **Persist results** – always store emails and scan logs in DB.
4. **Mock services for testing** – allows frontend development without real services.

---

## 7. Notes for Frontend Developers

* Use GraphQL queries and mutations for all interactions.
* Do **not** implement scanning in frontend; it is automatic.
* Use the `scan` field in emails to display results in the UI.
* Service routing is transparent – the frontend does not need to know if a mock or real service is used.

